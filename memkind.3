.\"
.\" Copyright (C) 2014 Intel Corperation.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions are met:
.\" 1. Redistributions of source code must retain the above copyright notice(s),
.\"    this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright notice(s),
.\"    this list of conditions and the following disclaimer in the documentation
.\"    and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY EXPRESS
.\" OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
.\" EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
.\" LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
.\" PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
.\" LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
.\" OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
.\" ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.TH "MEMKIND" 3 "25 May 2014" "Intel Corporation" "MEMKIND" \" -*- nroff -*-
.SH "NAME"
memkind \- Heap manager that isolates allocations to different kinds of numa nodes.
.SH "SYNOPSIS"
.nf
.B #include <memkind.h>
.sp
.B Link with -ljemalloc -lnuma -lmemkind -lpthread
.sp
.BI "void memkind_error_message(int " "err" ", char " "*msg" ", size_t " "size" );
.sp
.B "HEAP MANAGEMENT:"
.br
.BI "void *memkind_malloc(memkind_t " "kind" ", size_t " "size" );
.br
.BI "void *memkind_calloc(memkind_t " "kind" ", size_t " "num" ", size_t " "size" );
.br
.BI "void *memkind_realloc(memkind_t " "kind" ", void " "*ptr" ", size_t " "size" );
.br
.BI "void memkind_free(memkind_t " "kind" ", void " "*ptr" );
.br
.BI "int memkind_posix_memalign(memkind_t " "kind" ", void " "**memptr" ", size_t " "alignment" ", size_t " "size" );
.sp
.B "ALLOCATOR CALLBACK FUNCTIONS:"
.br
.BI "int memkind_partition_is_available(int " "partition" );
.br
.BI "int memkind_partition_get_mmap_flags(int " "partition" ", int " "*flags" );
.br
.BI "int memkind_partition_mbind(int " "partition" ", void " "*addr" ", size_t " "len" );
.sp
.B "KIND MANAGMENT:"
.br
.BI "int memkind_create(const struct memkind_ops " "*ops" ", const char " "*name" );
.br
.BI "int memkind_get_num_kind(int " "*num_kind" );
.br
.BI "int memkind_get_kind_by_partition(int " "partition" ", memkind_t " "*kind" );
.br
.BI "int memkind_get_kind_by_name(const char " "*name" ", memkind_t " "*kind" );
.br
.BI "int memkind_get_size(memkind_t " "kind" ", size_t " "*total" ", size_t " "*free" );
.br
.BI "int memkind_is_available(memkind_t " "kind" );
.br
.SH "DESCRIPTION"
.B "HEAP MANAGER:"
.br
The functions described in this section define a heap manager with an
interface modeled on the ISO C standard API's, except that the user
must specify the
.I kind
of memory with the first arguement to each function.  See the
.B KINDS
section below for a full description of the implemented kinds.
.PP
.BR memkind_malloc ()
allocates
.I size
bytes of uninitialized memory of the specified
.IR "kind" .
The allocated space is suitably aligned (after possible pointer
coercion) for storage of any type of object.  If
.I size
is 0, then
.BR memkind_malloc ()
returns  NULL.
.PP
.BR memkind_calloc ()
allocates space for
.I nmemb
objects each
.I size
bytes in length in memory of the specified
.IR "kind" .
The result is identical to calling
.BR memkind_malloc ()
with an argument of
.IR nmemb * size ,
with the exception that the allocated memory is explicitly
initialized to zero bytes.
If
.I nmemb
or
.I size
is 0, then
.BR memkind_calloc ()
returns NULL.
.PP
.BR memkind_realloc ()
changes the size of the previously allocated memory referenced by
.I ptr
to
.I size
bytes of the specified
.IR "kind" .
The contents of the memory are unchanged up to the lesser of
the new and old sizes. If the new size is larger, the contents of the
newly allocated portion of the memory are undefined. Upon success, the
memory referenced by
.I ptr
is freed and a pointer to the newly allocated high bandwidth memory is
returned. Note that
.BR memkind_realloc ()
may move the memory allocation, resulting in a different return value
than
.IR "ptr" .
If
.I ptr
is NULL, the
.BR memkind_realloc ()
function behaves identically to
.BR memkind_malloc ()
for the specified size.
The address
.IR "ptr" ,
if not NULL, must have been returned by a previous call to
.BR memkind_malloc (),
.BR memkind_calloc (),
.BR memkind_realloc (),
or
.BR memkind_posix_memalign ()
with the same
.I kind
as specified to the call to
.BR memkind_realloc ().
Otherwise, or if
.I memkind_free(kind, ptr)
has been called before, undefined behavior occurs.
.PP
.BR memkind_free ()
causes the allocated memory referenced by
.I ptr
to be made available for future allocations. This pointer
must have been returned by a previous call to
.BR memkind_malloc (),
.BR memkind_calloc (),
.BR memkind_realloc (),
or
.BR memkind_posix_memalign ().
Otherwise, or if
.I memkind_free(kind, ptr)
has already been called before, undefined behavior occurs.
If
.I ptr
is  NULL, no operation is performed.
For all currently supported kinds the the value of
.B MEMKIND_DEFAULT
or 0 can be given for the
.IR kind .
In the future there may be kinds introduced that will require that the
.I kind
specified to
.BR memkind_free ()
must match the value given when the memory to be freed was allocated.
.PP
.BR memkind_posix_memalign ()
allocates
.I size
bytes of memory of the specified
.I kind
such that the allocation's base address
is an even multiple of
.IR "alignment" ,
and returns the allocation in the value pointed to by
.IR "memptr" .
The requested
.I alignment
must be a power of 2 at least as large as
.IR "sizeof(void *)" .
If
.I size
is 0, then
.BR memkind_posix_memalign ()
returns NULL.
.sp
.B "LOW LEVEL INTERFACE:"
.br
This section describes the memkind low level interface which is used
internally by the heap manager interface.  For these API's the kind is
specified as an integer, rather than the abstract
.I memkind_t
used by the heap manager interface.
.PP
.BR memkind_error_message ()
converts an error number
.I err
returned by a member of the memkind
interface to an error message
.I msg
where the maximium size of the message is given by the
.I size
parameter.
.PP
.BR memkind_is_available ()
returns 1 if there is support for the specified
.I kind
on the system and 0 otherwise.
.PP
.BR memkind_get_mmap_flags ()
sets
.I flags
to the value appropriate for the
.I kind
when calling
.BR mmap (2).
.PP
.BR memkind_mbind ()
is a wrapper around
.BR mbind (2)
that simplifies the interface so that the user specifies the
.I kind
of memory, the start address
.I addr
to be mapped, and the number of bytes
.I len
from that address to be mapped. The memory is mapped to the nearest
NUMA node from the CPU of the calling process that is a member of the
specified kind.
.SH "RETURN VALUE"
.BR memkind_calloc (),
.BR memkind_malloc (),
and
.BR memkind_realloc (),
return the pointer to the allocated memory, or NULL if the request fails.
.BR memkind_free ()
and
.BR memkind_error_message ()
do not have return values.
.BR memkind_is_available()
returns 1 if there is support for the specified
.I kind
on the system and 0 otherwise.  All other memkind API's return 0 upon
success, and an error code defined in the ERRORS section upon failure.
The library sets
.I errno
to ENOMEM if the request could not be satisfied or when requesting a
negative size.  The library sets
.I errno
to EINVAL if the alignment is invalid.
.SH "KINDS"
The available kinds of memory
.TP
.B MEMKIND_DEFAULT
Default allocation using standard memory and default page size.
.TP
.B MEMKIND_HUGETLB
Allocate from standard memory using huge pages.
.TP
.B MEMKIND_HBW
Allocate from high bandwidth memory NUMA nodes as defined by the PMTT
table, or the environment variable
.BR "MEMKIND_HBW_NODES" .
If there is not enough high bandwidth memory to satisfy the request
.I errno
is set to ENOMEM and the allocated poitner is set to NULL.
.TP
.B MEMKIND_HBW_HUGETLB
Same as
.B MEMKIND_HBW
except the allocation uses huge pages.
.TP
.B MEMKIND_HBW_PREFERRED
Same as
.B MEMKIND_HBW
except that if there is not enough high bandwidth memory to satisfy the
request, the allocation will fall back on standard memory.
.TP
.B MEMKIND_HBW_PREFERRED_HUGETLB
Same as
.B MEMKIND_HBW_PREFERRED
except the allocation uses huge pages.
.TP
.B MEMKIND_HBW_GBTLB
Same as
.B MEMKIND_HBW_HUGETLB
except the allocation uses one gigabyte huge pages.
.TP
.B MEMKIND_HBW_PREFERRED_GBTLB
Same as
.B MEMKIND_HBW_PREFERRED_HUGETLB
except the allocation uses one gigabyte huge pages.
Both
.B MEMKIND_HBW_GBTLB
and
.B MEMKIND_HBW_PREFERRED_GBTLB
require size which should be a multiple of 1GB.
.TP
.B MEMKIND_HBW_GBRO
Same as
.B MEMKIND_HBW_GBTLB
except it allow the user to specify random sizes
backed by one gigabyte pages.
.TP
.B MEMKIND_HBW_PREFERRED_GBRO
Same as
.B MEMKIND_HBW_GBRO
except that if there is not enough high bandwidth memory one gigabyte pages
to satisfy the request, the allocation will fall back
on standard memory.
.PP
.SH "ERRORS"
.TP
.B MEMKIND_ERROR_UNAVAILABLE
Requested memory kind is not available
.TP
.B MEMKIND_ERROR_MBIND
Call to mbind() failed
.TP
.B MEMKIND_ERROR_MMAP
Call to mmap() failed
.TP
.B MEMKIND_ERROR_MEMALIGN
Call to posix_memalign() failed
.TP
.B MEMKIND_ERROR_MALLCTL
Call to je_mallctl() failed
.TP
.B MEMKIND_ERROR_MALLOC
Call to je_malloc() failed
.TP
.B MEMKIND_ERROR_GETCPU
Call to sched_getcpu() returned out of range
.TP
.B MEMKIND_ERROR_PMTT
Unable to find parsed PMTT table or
invalid PMTT table entries in
.I /etc/memkind/node-bandwidth
.TP
.B MEMKIND_ERROR_TIEDISTANCE
Two NUMA memory nodes are equidistant from target cpu node
.TP
.B MEMKIND_ERROR_ALIGNMENT
Alignment must be a power of two and larger than sizeof(void *)
.TP
.B MEMKIND_ERROR_ALLOCM
Call to je_allocm() failed
.TP
.B MEMKIND_ERROR_ENVIRON
Error parsing environment variable (MEMKIND_*)
.TP
.B MEMKIND_ERROR_INVALID
Invalid input arguments to memkind routine
.SH "FILES"
.TP
.I /etc/memkind/node-bandwidth
File that contains the bandwidth values for each numa node.
.TP
.I /etc/rc/d/init.d/memkind
Initialization script that creates the node-bandwidth file by calling
the PMTT table parser.
.TP
.I /usr/sbin/memkind-pmtt
The PMTT table parser.

.SH "ENVIRONMENT"
.TP
.B MEMKIND_HBW_NODES
This environment varaible is a comma separated list of NUMA nodes that
are treated as high bandwidth. This environment variable should be set
if the PMTT file is not present, or to override the PMTT table if it
is present. Uses the
.I libnuma
routine
.BR numa_parse_nodestring ()
for parsing, so the syntax described in the
.BR numa (3)
man page for this routine applies: e.g 1-3,5 is a valid setting.
.SH "COPYRIGHT"
Copyright (C) 2014 Intel Corperation. All rights reserved.
.SH "SEE ALSO"
.BR malloc (3),
.BR numa (3),
.BR numactl (8),
.BR mbind (2),
.BR mmap (2),
.BR move_pages (2)
.BR jemalloc (3)
